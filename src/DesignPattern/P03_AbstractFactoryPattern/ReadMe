http://blog.csdn.net/jjwwmlp456/article/details/39637255


工厂方法模式：
一个抽象产品类，可以派生出多个具体产品类。   
一个抽象工厂类，可以派生出多个具体工厂类。   
每个具体工厂类只能创建一个具体产品类的实例。

抽象工厂模式：
多个抽象产品类，每个抽象产品类可以派生出多个具体产品类。   
一个抽象工厂类，可以派生出多个具体工厂类。   
每个具体工厂类可以创建多个具体产品类的实例。   
    
区别：
工厂方法模式只有一个抽象产品类，而抽象工厂模式有多个。   
工厂方法模式的具体工厂类只能创建一个具体产品类的实例，而抽象工厂模式可以创建多个。

 应用场景
工厂方法：
在以下情况下，适用于工厂方法模式：
(1) 当一个类不知道它所必须创建的对象的类的时候。
(2) 当一个类希望由它的子类来指定它所创建的对象的时候。
(3) 当类将创建对象的职责委托给多个帮助子类中的某一个，并且你希望将哪一个帮助子类是代理者这一信息局部化的时候。
抽象工厂：
(1) 一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节，这对于所有形态的工厂模式都是重要的。
(2) 这个系统有多于一个的产品族，而系统只消费其中某一产品族。
(3) 同属于同一个产品族的产品是在一起使用的，这一约束必须在系统的设计中体现出来。
(4) 系统提供一个产品类的库，所有的产品以同样的接口出现，从而使客户端不依赖于实现。
 
为什么要用工厂模式？
（1）到处用new class（）的方式，一旦要改class，要到处替换，非常不方便，容易错；
（2）使用工厂模式，可以轻松的增加一个新的产品，不需要改原来的代码，符合开放封闭原则。
（3）工厂这个模式它可以隐藏函数的具体实现，并且更加具有封装性，更加的面向对象，这些东西在基础的编写小程序上并体现不出什么优越性，但在一个大项目中，就显得很重要了，打个比方就像你如果说只有两三本书，你不需要什么归类放着，但你如果有一个图书管那么多书的话，放书就要有一定的规章，章法，这样就好管理，变更，查找。